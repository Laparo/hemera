name: E2E Tests

on:
  workflow_dispatch:
    inputs:
      url:
        description: 'Base URL for E2E (e.g., https://hemera-<preview>.vercel.app)'
        required: false
  pull_request:
    types: [opened, synchronize, reopened]
  deployment_status:

jobs:
  e2e:
    runs-on: ubuntu-latest
    # Run on PR events or when a preview deployment succeeds
    if: |
      github.event_name != 'deployment_status' ||
      (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Install jq (for parsing event payload)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Determine Base URL
        id: base
        run: |
          if [ -n "${{ inputs.url }}" ]; then
            echo "base=${{ inputs.url }}" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" = "deployment_status" ]; then
            ENV_URL=$(jq -r '.deployment_status.environment_url // empty' "$GITHUB_EVENT_PATH")
            TARGET=$(jq -r '.deployment_status.target_url // empty' "$GITHUB_EVENT_PATH")
            URL="${ENV_URL:-$TARGET}"
            if [ -n "$URL" ]; then
              echo "base=$URL" >> "$GITHUB_OUTPUT"
            else
              echo "base=http://localhost:3000" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "base=http://localhost:3000" >> "$GITHUB_OUTPUT"
          fi

      - name: Check base reachability and SSO redirect
        id: basecheck
        run: |
          RAW_BASE="${{ steps.base.outputs.base }}"
          # Normalize trailing slash
          RAW_BASE=${RAW_BASE%/}
          CHECK_URL_API="$RAW_BASE/api/health"
          CHECK_URL_ROOT="$RAW_BASE/"
          echo "Checking reachability: $CHECK_URL_API and $CHECK_URL_ROOT"
          # Get final effective URL after redirects and the HTTP status for both
          EFFECTIVE_API=$(curl -s -L -o /dev/null -w "%{url_effective}" "$CHECK_URL_API") || true
          STATUS_API=$(curl -s -o /dev/null -w "%{http_code}" "$CHECK_URL_API") || STATUS_API=000
          EFFECTIVE_ROOT=$(curl -s -L -o /dev/null -w "%{url_effective}" "$CHECK_URL_ROOT") || true
          STATUS_ROOT=$(curl -s -o /dev/null -w "%{http_code}" "$CHECK_URL_ROOT") || STATUS_ROOT=000
          echo "API Effective: ${EFFECTIVE_API:-$CHECK_URL_API} (status: $STATUS_API)"
          echo "ROOT Effective: ${EFFECTIVE_ROOT:-$CHECK_URL_ROOT} (status: $STATUS_ROOT)"
          USE_LOCAL=0
          FINAL_BASE="$RAW_BASE"
          # If the URL redirects to Vercel login/SSO or non-2xx, fall back to localhost
          if echo "$EFFECTIVE_API $EFFECTIVE_ROOT" | grep -qi "vercel.com/login" || echo "$EFFECTIVE_API $EFFECTIVE_ROOT" | grep -qi "/sso-api" || [ "$STATUS_API" -lt 200 ] || [ "$STATUS_API" -ge 400 ] || [ "$STATUS_ROOT" -lt 200 ] || [ "$STATUS_ROOT" -ge 400 ]; then
            echo "Preview appears protected by Vercel SSO or unreachable. Falling back to local server."
            USE_LOCAL=1
            FINAL_BASE="http://localhost:3000"
          fi
          echo "use_local=$USE_LOCAL" >> "$GITHUB_OUTPUT"
          echo "final_base=$FINAL_BASE" >> "$GITHUB_OUTPUT"

      - name: Selected base URL
        run: |
          echo "Using base URL: ${{ steps.basecheck.outputs.final_base }} (use_local=${{ steps.basecheck.outputs.use_local }})"

      - name: Setup test database and environment
        run: |
          # Create a minimal .env.local for tests with mock Clerk keys
          cat > .env.local << EOF
          NEXTAUTH_URL=http://localhost:3000
          NEXTAUTH_SECRET=test-secret-for-ci-only
          DATABASE_URL=file:./test.db

          # Mock Clerk configuration for CI tests
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_mock_ci_key_for_testing_only
          CLERK_SECRET_KEY=sk_test_mock_ci_secret_for_testing_only
          NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
          NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
          NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
          NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard
          EOF

          # Create a temporary SQLite schema for CI testing
          cp prisma/schema.prisma prisma/schema.prisma.backup
          sed -i 's/provider = "postgresql"/provider = "sqlite"/g' prisma/schema.prisma
          sed -i 's/@db\.Text//g' prisma/schema.prisma
          sed -i 's/@db\.VarChar([0-9]*)//g' prisma/schema.prisma

      - name: Run Prisma setup
        run: |
          # Clear any cached Prisma clients and Next.js build artifacts
          rm -rf .next node_modules/.prisma

          npx prisma generate
          npx prisma db push --force-reset
          npx prisma db seed
          # Verify seed data
          echo "Verifying seed data..."
          npx prisma db execute --stdin <<'SQL'
          SELECT
            COUNT(*) AS published_count
          FROM courses
          WHERE isPublished = 1;
          SQL
          # Export lightweight debug context for later troubleshooting
          node <<'NODE'
          const fs = require('fs');
          const path = '/tmp/course-debug.json';
          const { PrismaClient } = require('@prisma/client');
          const prisma = new PrismaClient();
          (async () => {
            const [publishedCount, sampleCourses] = await Promise.all([
              prisma.course.count({ where: { isPublished: true } }),
              prisma.course.findMany({
              where: { isPublished: true },
              select: { id: true, title: true, slug: true },
              orderBy: { createdAt: 'desc' },
                take: 5,
              }),
            ]);
            const payload = {
              generatedAt: new Date().toISOString(),
              publishedCount,
              sample: sampleCourses,
            };
            fs.writeFileSync(path, JSON.stringify(payload, null, 2));
            console.log('Saved course debug snapshot to', path);
            console.log('Seed verification - published courses:', publishedCount);
          })()
            .catch(error => {
              console.error('Failed to write course debug snapshot:', error);
            })
            .finally(async () => {
              await prisma.$disconnect();
            });
          NODE
        env:
          DATABASE_URL: file:./test.db

      - name: Start Next.js server in background
        if: steps.basecheck.outputs.use_local == '1'
        run: |
          npm run dev &
          # Wait for server to be ready
          timeout 60 bash -c 'until curl -f http://localhost:3000/api/health; do sleep 2; done'
        env:
          NODE_ENV: development
          DATABASE_URL: file:./test.db
          E2E_TEST: true
          NEXT_PUBLIC_DISABLE_CLERK: 1
          NEXT_PUBLIC_DISABLE_ROLLBAR: 1

      - name: Run E2E tests
        id: e2e
        continue-on-error: true
        env:
          PLAYWRIGHT_BASE_URL: ${{ steps.basecheck.outputs.final_base }}
        run: npm run e2e:dev

      - name: Debug - Check course data
        if: always()
        run: |
          echo "=== Course Debug Information ==="
          if [ -f /tmp/course-debug.json ]; then
            cat /tmp/course-debug.json
          else
            echo "Debug file not found"
          fi
          echo "=== E2E Test Result: ${{ steps.e2e.outcome }} ==="

      - name: Upload Playwright HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report
          if-no-files-found: warn

      - name: Comment E2E result on PR
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          BASE_URL: ${{ steps.basecheck.outputs.final_base }}
          OUTCOME: ${{ steps.e2e.outcome }}
        with:
          script: |
            const bodyMarker = '<!-- hemera-e2e-result -->';
            const outcome = process.env.OUTCOME || 'unknown';
            const base = process.env.BASE_URL || 'http://localhost:3000';
            const emoji = outcome === 'success' ? '✅' : (outcome === 'failure' ? '❌' : 'ℹ️');
            const body = `${bodyMarker}\n${emoji} E2E (${outcome}) against ${base}.\n` +
              `Artifacts: see 'playwright-report' in the Actions run.`;
            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;
            try {
              const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number });
              const existing = comments.find(c => (c.user?.type === 'Bot' || c.user?.login?.includes('[bot]')) && c.body?.includes(bodyMarker));
              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number, body });
              }
            } catch (error) {
              console.log('Could not comment on PR:', error.message);
            }

      - name: Fail if tests failed
        if: ${{ steps.e2e.outcome == 'failure' }}
        run: |
          echo "E2E tests failed" >&2
          exit 1

      - name: Restore Prisma schema
        if: always()
        run: |
          if [ -f prisma/schema.prisma.backup ]; then
            mv prisma/schema.prisma.backup prisma/schema.prisma
          fi
