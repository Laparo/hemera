name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment target (preview or production)'
        type: choice
        required: true
        default: production
        options:
          - preview
          - production

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  # Central production alias used for health checks and E2E
  PRODUCTION_ALIAS: https://hemera-tau.vercel.app

jobs:
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 20
    services:
      postgres:
        image: postgres:16
        # ports mapping above
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: hemera_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d hemera_test"
          --health-interval 5s
          --health-timeout 10s
          --health-retries 30
          --health-start-period 20s
    env:
      NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
      CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      # Use 127.0.0.1:5432 mapping for the Postgres service (force IPv4)
      DATABASE_URL: 'postgresql://postgres:postgres@127.0.0.1:5432/hemera_test'
      NEXT_PUBLIC_CLERK_SIGN_IN_URL: /sign-in
      NEXT_PUBLIC_CLERK_SIGN_UP_URL: /sign-up
      NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL: /dashboard
      NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL: /dashboard

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Set BUILD_TIME (UTC)
        run: echo "BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_ENV"

      - name: Install dependencies
        run: npm ci

      - name: Install Postgres client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Wait for Postgres to be ready
        env:
          PGPASSWORD: postgres
          PGUSER: postgres
          PGDATABASE: hemera_test
          PGHOST: 127.0.0.1
          PGPORT: 5432
        shell: bash
        run: |
          echo "Waiting for Postgres service health and connectivity on $PGHOST:$PGPORT..."
          attempts=0
          max_attempts=60 # 60 * 5s = 5 minutes
          until pg_isready -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE"; do
            attempts=$((attempts+1))
            if [[ $attempts -ge $max_attempts ]]; then
              echo "Postgres not ready after $((max_attempts*5)) seconds (pg_isready)." >&2
              echo "\n==== docker ps ===="
              docker ps -a || true
              echo "\n==== postgres logs (best-effort) ===="
              docker logs $(docker ps -aq --filter name=postgres --filter ancestor=postgres:16 | head -n1) 2>/dev/null || true
              exit 1
            fi
            echo "Waiting for Postgres (pg_isready) attempt ${attempts}/${max_attempts} ...";
            sleep 5;
          done
          echo "pg_isready reports ready. Verifying SQL connection..."
          # Verify authentication and database availability
          for i in {1..10}; do
            if psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "SELECT 1;" >/dev/null 2>&1; then
              echo "Successfully connected to $PGDATABASE via psql."; break
            fi
            echo "psql connection attempt $i/10 failed, retrying in 3s..."; sleep 3;
            if [[ $i -eq 10 ]]; then
              echo "Failed to connect to Postgres via psql after multiple attempts." >&2
              exit 1
            fi
          done

      - name: Setup database schema
        run: npx prisma migrate deploy

      - name: Type checking
        run: npx tsc --noEmit

      - name: Prettier formatting check
        run: npm run format:check

      - name: ESLint validation
        run: npm run lint:ci

      - name: Run unit tests (with coverage)
        run: npm test -- --coverage

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage
          path: coverage/
          retention-days: 7

      - name: Build verification
        run: npm run build
        env:
          BUILD_TIME: ${{ env.BUILD_TIME }}

  # Export a UTC timestamp for BUILD_TIME at workflow start (reusable)
  # Note: This env will be available to subsequent steps as ${{ env.BUILD_TIME }}
  # We define it via a dedicated job to avoid repetition; downstream jobs can still set/override per-step if needed.
  # GitHub Actions does not support dynamic env at workflow root from steps, so we set it in-place in jobs where needed too.

  deploy-preview:
    name: Deploy Preview
    runs-on: ubuntu-latest
    needs: quality-gates
    # Run on PRs, or manual dispatch explicitly targeting preview on any ref
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'preview')
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Sanitize Vercel Token
        run: |
          set -euo pipefail
          token=$(printf %s "${{ secrets.VERCEL_TOKEN }}" | tr -d '"' | tr -d "\n\r\t" | sed -e 's/^ *//' -e 's/ *$//')
          echo "SANITIZED_VERCEL_TOKEN=$token" >> "$GITHUB_ENV"

      - name: Set BUILD_TIME (UTC)
        run: echo "BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_ENV"

      - name: Pull Vercel Environment Information
        run: vercel pull --yes --environment=preview --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build Project Artifacts
        run: vercel build --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          BUILD_TIME: ${{ env.BUILD_TIME }}
          # Temporary safeguard: disable Clerk during preview build to avoid prerender failures
          NEXT_PUBLIC_DISABLE_CLERK: 1

      - name: Deploy Project Artifacts to Vercel
        id: deploy
        run: |
          url=$(vercel deploy --prebuilt --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID" --yes)
          echo "url=$url" >> "$GITHUB_OUTPUT"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Comment PR with Preview URL
        if: github.event_name == 'pull_request' && steps.deploy.outputs.url != ''
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'ðŸš€ Preview deployment: ${{ steps.deploy.outputs.url }}'
            })

      - name: Output Preview URL (non-PR)
        if: github.event_name != 'pull_request' && steps.deploy.outputs.url != ''
        run: |
          echo "Preview URL=${{ steps.deploy.outputs.url }}" | tee -a "$GITHUB_STEP_SUMMARY"

  deploy-production:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: quality-gates
    # Run on push to main, or manual dispatch on main targeting production
    if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'production')
    # Production deploys on Vercel can take longer (build + finalize). Bump timeout to avoid premature cancellation.
    timeout-minutes: 60

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Sanitize Vercel Token
        run: |
          set -euo pipefail
          token=$(printf %s "${{ secrets.VERCEL_TOKEN }}" | tr -d '"' | tr -d "\n\r\t" | sed -e 's/^ *//' -e 's/ *$//')
          echo "SANITIZED_VERCEL_TOKEN=$token" >> "$GITHUB_ENV"

      - name: Set BUILD_TIME (UTC)
        run: echo "BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_ENV"

      - name: Pull Vercel Environment Information
        run: vercel pull --yes --environment=production --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build Project Artifacts
        run: vercel build --prod --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          BUILD_TIME: ${{ env.BUILD_TIME }}

      - name: Deploy Project Artifacts to Vercel (non-blocking with fallback)
        id: deploy
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Starting Vercel production deploy (prebuilt)â€¦"
          # Try to deploy with a bounded timeout to avoid long blocking waits
          # If the CLI prints the URL, capture it; otherwise, fallback to API to discover latest prod deployment
          url=""
          if timeout 15m bash -c 'vercel deploy --prebuilt --prod --token="$SANITIZED_VERCEL_TOKEN" --scope="$VERCEL_ORG_ID" --yes | tee deploy.out'; then
            # Try to extract a https URL from CLI output (prefer custom domain, then *.vercel.app)
            if grep -Eo 'https?://[a-zA-Z0-9._-]+' deploy.out | head -n1 >/dev/null; then
              url=$(grep -Eo 'https?://[a-zA-Z0-9._-]+' deploy.out | head -n1)
            fi
          else
            echo "vercel deploy timed out after 15m; will try to discover deployment via APIâ€¦" >&2
          fi

          if [[ -z "${url}" ]]; then
            echo "Attempting to fetch latest production deployment via Vercel API v13â€¦"
            api_resp=$(curl -fsSL -H "Authorization: Bearer $SANITIZED_VERCEL_TOKEN" \
              "https://api.vercel.com/v13/deployments?projectId=${VERCEL_PROJECT_ID}&target=production&limit=1") || true
            if [[ -n "${api_resp:-}" ]]; then
              deploy_url=$(echo "$api_resp" | jq -r '.deployments[0].url // empty' 2>/dev/null || true)
              if [[ -n "${deploy_url:-}" ]]; then
                # API returns host without scheme sometimes
                if [[ "$deploy_url" =~ ^https?:// ]]; then
                  url="$deploy_url"
                else
                  url="https://$deploy_url"
                fi
              fi
            fi
          fi

          if [[ -z "${url}" ]]; then
            echo "Attempting to fetch latest production deployment via Vercel API v6â€¦"
            api_resp_v6=$(curl -fsSL -H "Authorization: Bearer $SANITIZED_VERCEL_TOKEN" \
              "https://api.vercel.com/v6/deployments?projectId=${VERCEL_PROJECT_ID}&target=production&limit=1&teamId=${VERCEL_ORG_ID}") || true
            if [[ -n "${api_resp_v6:-}" ]]; then
              deploy_url=$(echo "$api_resp_v6" | jq -r '.deployments[0].url // empty' 2>/dev/null || true)
              if [[ -n "${deploy_url:-}" ]]; then
                if [[ "$deploy_url" =~ ^https?:// ]]; then
                  url="$deploy_url"
                else
                  url="https://$deploy_url"
                fi
              fi
            fi
          fi

          if [[ -z "${url}" ]]; then
            # As a final fallback, assume the known production alias (kept in sync with E2E job)
            url="${PRODUCTION_ALIAS}"
            echo "Falling back to known production alias: $url"
          fi

          echo "Deployment candidate URL: $url"
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Poll Deployment Readiness (health check)
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}
          DEPLOY_ALIAS: ${{ env.PRODUCTION_ALIAS }}
        shell: bash
        run: |
          set -euo pipefail
          url="$DEPLOY_URL"
          alias_url="${DEPLOY_ALIAS:-}"
          if [[ -z "$url" ]]; then
            echo "No DEPLOY_URL provided to polling step." >&2
            exit 1
          fi

          if [[ -z "$alias_url" ]]; then
            echo "No DEPLOY_ALIAS provided; will poll only discovered URL."
          fi

          echo "Polling readiness until healthy..."
          echo "- Discovered URL: ${url}/api/health"
          if [[ -n "$alias_url" && "$alias_url" != "$url" ]]; then
            echo "- Production alias: ${alias_url}/api/health"
          fi
          attempts=0
          max_attempts=80   # ~40 minutes @ 30s interval
          success_streak=0
          required_streak=2 # require two consecutive 200 to avoid transient readiness
          while true; do
            attempts=$((attempts+1))
            code_main=$(curl -s -o /dev/null -w "%{http_code}" "${url%/}/api/health" || true)
            code_alias=""
            if [[ -n "$alias_url" && "$alias_url" != "$url" ]]; then
              code_alias=$(curl -s -o /dev/null -w "%{http_code}" "${alias_url%/}/api/health" || true)
            fi

            if [[ "$code_main" == "200" || "$code_alias" == "200" ]]; then
              success_streak=$((success_streak+1))
              which_ok="$( [[ "$code_main" == "200" ]] && echo main || echo alias )"
              echo "[$attempts] Health OK on $which_ok (200). Streak=${success_streak}/${required_streak}"
              if [[ $success_streak -ge $required_streak ]]; then
                echo "Deployment is healthy."
                break
              fi
            else
              echo "[$attempts] Not ready (main=$code_main alias=${code_alias:-n/a}). Reset streak."
              success_streak=0
            fi

            if [[ $attempts -ge $max_attempts ]]; then
              echo "Deployment did not become healthy within the polling window (~40m)." >&2
              echo "Last observed codes: main=$code_main alias=${code_alias:-n/a}" >&2
              exit 1
            fi
            sleep 30
          done

      - name: Print Deployment URL
        if: always()
        run: |
          echo "Discovered URL=${{ steps.deploy.outputs.url }}" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "Production alias=${{ env.PRODUCTION_ALIAS }}" | tee -a "$GITHUB_STEP_SUMMARY"

  check-frontend-changes:
    name: Check Frontend Changes
    runs-on: ubuntu-latest
    outputs:
      has_frontend_changes: ${{ steps.check.outputs.has_frontend_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for frontend changes
        id: check
        run: |
          # Define patterns for frontend files
          # - Pages and layouts in app/ (excluding api/)
          # - Components
          # - Public assets
          # - Styles
          frontend_patterns=(
            'app/.*\.(tsx|jsx)$'
            'components/.*\.(tsx|jsx|ts|js)$'
            'public/.*'
            'styles/.*\.(css|scss|sass)$'
          )

          # Exclude API routes
          exclude_patterns=(
            'app/api/.*'
          )

          # Get changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.sha }})
          else
            # For pushes, compare with previous commit
            changed_files=$(git diff --name-only HEAD~1 HEAD)
          fi

          has_frontend_changes=false

          # Check each changed file against patterns
          while IFS= read -r file; do
            # Skip if matches exclude patterns
            excluded=false
            for exclude_pattern in "${exclude_patterns[@]}"; do
              if echo "$file" | grep -qE "$exclude_pattern"; then
                excluded=true
                break
              fi
            done
            
            if [ "$excluded" = true ]; then
              continue
            fi
            
            # Check if matches frontend patterns
            for pattern in "${frontend_patterns[@]}"; do
              if echo "$file" | grep -qE "$pattern"; then
                echo "Found frontend change: $file"
                has_frontend_changes=true
                break 2
              fi
            done
          done <<< "$changed_files"

          echo "has_frontend_changes=$has_frontend_changes" >> "$GITHUB_OUTPUT"
          echo "Frontend changes detected: $has_frontend_changes"

  e2e-production:
    name: E2E Tests (Production)
    runs-on: ubuntu-latest
    needs: [deploy-production, check-frontend-changes]
    # Run after production deploy on push to main, or on manual dispatch on main
    # Skip if no frontend changes detected
    if: |
      needs.check-frontend-changes.outputs.has_frontend_changes == 'true' &&
      ((github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'production'))
    timeout-minutes: 20
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright Browsers
        run: npx playwright install --with-deps

      - name: Run E2E tests against production
        run: npx playwright test --project=chromium
        env:
          PLAYWRIGHT_BASE_URL: ${{ env.PRODUCTION_ALIAS }}

      - name: Upload Playwright Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report-production
          path: playwright-report/
          retention-days: 30

  close-branch:
    name: Close Branch
    runs-on: ubuntu-latest
    needs: [deploy-production, e2e-production]
    # Only on main after production flow completes (push or manual dispatch on main)
    # Always run regardless of e2e-production outcome (it may be skipped)
    if: |
      always() &&
      needs.deploy-production.result == 'success' &&
      (needs.e2e-production.result == 'success' || needs.e2e-production.result == 'skipped') &&
      ((github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'production'))
    steps:
      - name: Close branch after successful production deployment
        run: |
          if [ "${{ needs.e2e-production.result }}" == "skipped" ]; then
            echo "Branch will be closed after successful production build (E2E tests were skipped due to no frontend changes)"
          else
            echo "Branch will be closed after successful production build and E2E tests"
          fi
